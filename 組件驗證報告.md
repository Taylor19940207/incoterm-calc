# Incoterm 計算器組件驗證報告

## 📊 **組件架構總覽**

### **數據流向：**
```
inputs (用戶輸入) → calculateAllProductQuotes() → productQuotes → UI 組件
```

### **核心計算函數：**
- `calculateAllProductQuotes(inputs)` - 計算所有商品報價
- `calculateCostBreakdown(inputs)` - 計算成本明細
- `calculateProductQuote(product, inputs)` - 計算個別商品報價

---

## 🎯 **1. 計算結果組件 (計算結果)**

### **數據來源：**
- **單位報價**：`productQuotes.products[0]?.suggestedQuote`
- **單位成本**：`productQuotes.products[0]?.unitCost`
- **總報價**：`productQuotes.products.reduce((sum, p) => sum + p.totalProductValue, 0)`
- **毛利率**：`profitMargin` (動態計算)

### **毛利率計算邏輯：**
```typescript
const profitMargin = useMemo(() => {
  const product = productQuotes.products[0];
  if (product?.suggestedQuote && product?.unitCost && product.suggestedQuote > 0) {
    const margin = (product.suggestedQuote - product.unitCost) / product.suggestedQuote;
    return margin; // 返回小數值，如 0.1198
  }
  return 0;
}, [productQuotes.products]);
```

### **顯示格式化：**
```typescript
// labelPct 函數會將小數值乘以 100 並加上 % 符號
const labelPct = useCallback((val: number) => 
  `${(val * 100).toFixed(2)}%`, []
);
```

### **驗證結果：**
- ✅ **數據來源統一** - 全部使用 `productQuotes` 數據
- ✅ **計算邏輯正確** - 毛利率 = (售價 - 成本) / 售價
- ✅ **格式化正確** - 避免雙重乘以 100 的問題

---

## 📋 **2. 成本明細表組件 (成本明細)**

### **數據來源：**
- **供應商貨值**：`derived.sumVal`
- **各項費用**：`productQuotes.costBreakdown.*`

### **適用性判斷邏輯：**
```typescript
// 舊邏輯 (已移除)
{calc.need_EXW_to_FOB && (費用項目)}

// 新邏輯 (現用)
{productQuotes.costBreakdown.logisticsCosts.inlandToPort > 0 && (費用項目)}
```

### **費用項目對應：**
| 費用項目 | 數據來源 | 適用性判斷 |
|---------|----------|------------|
| 工廠到港口 | `logisticsCosts.inlandToPort` | `> 0` |
| 出口文件 | `fixedCosts.exportDocsClearance` | `> 0` |
| 港口雜費 | `fixedCosts.originPortFees` | `> 0` |
| 海運/空運 | `logisticsCosts.mainFreight` | `> 0` |
| 貨物保險 | `logisticsCosts.insurance` | `> 0` |
| 目的港雜費 | `fixedCosts.destPortFees` | `> 0` |
| 進口代理 | `fixedCosts.importBroker` | `> 0` |
| 末端配送 | `fixedCosts.lastMileDelivery` | `> 0` |
| 雜項費用 | `fixedCosts.misc` | 總是顯示 |

### **驗證結果：**
- ✅ **適用性判斷統一** - 使用新邏輯的實際費用值
- ✅ **數據來源一致** - 全部使用 `productQuotes.costBreakdown`
- ✅ **貿易條件正確** - FOB→FOB 不會顯示不適用的費用

---

## 🏷️ **3. 商品個別報價組件 (商品1)**

### **數據來源：**
- **數量**：`product.qty`
- **供應商單價**：`product.supplierUnitPrice`
- **單位成本**：`product.unitCost`
- **建議報價**：`product.suggestedQuote`
- **單位利潤**：`product.unitProfit`
- **商品總價**：`product.totalProductValue`

### **計算邏輯：**
```typescript
// 單位成本 = 供應商單價 + 分攤成本
const unitCost = supplierUnitPrice + productAllocation.perUnitAllocatedCosts;

// 建議報價 = 單位成本 × (1 + 加價率%) 或 單位成本 ÷ (1 - 毛利率%)
let suggestedQuote = unitCost;
if (inputs.pricingMode === 'markup') {
  suggestedQuote = unitCost * (1 + (inputs.markupPct || 0) / 100);
} else if (inputs.pricingMode === 'margin') {
  const margin = (inputs.marginPct || 0) / 100;
  suggestedQuote = unitCost / (1 - margin);
}

// 單位利潤 = 建議報價 - 單位成本
const unitProfit = suggestedQuote - unitCost;

// 商品總價 = 建議報價 × 數量
const totalProductValue = suggestedQuote * productQty;
```

### **驗證結果：**
- ✅ **數據來源統一** - 全部使用 `productQuotes.products[0]`
- ✅ **計算邏輯正確** - 符合您給的定價公式
- ✅ **利潤計算正確** - 單位利潤 = 建議報價 - 單位成本

---

## 📊 **4. 總計組件 (總計)**

### **數據來源：**
- **總數量**：`productQuotes.products.reduce((sum, p) => sum + p.qty, 0)`
- **總利潤**：`productQuotes.products.reduce((sum, p) => sum + p.unitProfit * p.qty, 0)`
- **總報價**：`productQuotes.products.reduce((sum, p) => sum + p.totalProductValue, 0)`

### **驗證結果：**
- ✅ **數據來源統一** - 全部使用 `productQuotes.products` 的匯總
- ✅ **計算邏輯正確** - 數量、利潤、報價的總和計算

---

## 🔧 **5. 核心計算函數驗證**

### **calculateCostBreakdown 函數：**
```typescript
export function calculateCostBreakdown(inputs: Inputs) {
  // 使用統一的 calculateQuote 函數
  const quoteResult = calculateQuote({...});
  
  // 根據貿易條件過濾費用
  const add = {
    inlandToPort: inputs.supplierTerm === "EXW" && idx(inputs.targetTerm) >= idx("FOB"),
    exportDocs: idx(inputs.targetTerm) >= idx("FOB"),
    mainFreight: idx(inputs.targetTerm) >= idx("CFR") && idx(inputs.supplierTerm) < idx("CFR"),
    insurance: idx(inputs.targetTerm) >= idx("CIF") && idx(inputs.supplierTerm) < idx("CIF"),
    // ... 其他費用
  };
  
  // 分類成本
  const fixedCosts = {...};
  const logisticsCosts = {...};
  
  return {
    fixedCosts,
    logisticsCosts,
    totalCosts: totalFixedCosts + totalLogisticsCosts,
    costAllocation
  };
}
```

### **calculateProductQuote 函數：**
```typescript
export function calculateProductQuote(product: Product, inputs: Inputs) {
  const costBreakdown = calculateCostBreakdown(inputs);
  const productAllocation = costBreakdown.costAllocation.find(...);
  
  // 單位成本 = 供應商單價 + 分攤成本
  const unitCost = supplierUnitPrice + productAllocation.perUnitAllocatedCosts;
  
  // 建議報價計算
  let suggestedQuote = unitCost;
  if (inputs.pricingMode === 'markup') {
    suggestedQuote = unitCost * (1 + (inputs.markupPct || 0) / 100);
  } else if (inputs.pricingMode === 'margin') {
    const margin = (inputs.marginPct || 0) / 100;
    suggestedQuote = unitCost / (1 - margin);
  }
  
  return {
    unitCost,
    suggestedQuote,
    unitProfit: suggestedQuote - unitCost,
    totalProductValue: suggestedQuote * productQty
  };
}
```

---

## ✅ **總結驗證結果**

### **數據一致性：**
- ✅ **所有組件都使用統一的數據源** - `productQuotes`
- ✅ **沒有混合使用舊邏輯和新邏輯**
- ✅ **成本計算和報價計算使用相同的基礎數據**

### **計算邏輯正確性：**
- ✅ **毛利率計算** - (售價 - 成本) / 售價
- ✅ **定價公式** - 符合您給的加價率和毛利率公式
- ✅ **成本分攤** - 根據選擇的分攤方式正確計算
- ✅ **適用性判斷** - 根據貿易條件正確過濾費用

### **顯示邏輯正確性：**
- ✅ **避免雙重百分比轉換** - 毛利率計算不乘以 100，由 `labelPct` 處理
- ✅ **費用項目顯示** - 只顯示實際有費用的項目
- ✅ **貿易條件適用性** - FOB→FOB 不會顯示 EXW→FOB 的費用

### **最終結果：**
- **毛利率應該顯示**：11.98% (而不是 1198.32%)
- **所有數值應該一致**：上半部和下半部的數據完全匹配
- **費用適用性正確**：只顯示真正適用的費用項目

---

## 📝 **建議測試案例**

1. **貿易條件：FOB → FOB**
   - 應該只顯示：供應商貨值、出口文件
   - 不應該顯示：工廠到港口、港口雜費、海運/空運、貨物保險等

2. **貿易條件：EXW → CIF**
   - 應該顯示：供應商貨值、工廠到港口、出口文件、港口雜費、海運/空運、貨物保險

3. **毛利率驗證**
   - 成本：JPY 302.78
   - 報價：JPY 344.00
   - 毛利率：應該顯示 11.98%

---

*報告生成時間：2024年12月*
*驗證狀態：所有組件邏輯已統一，數據來源一致*
